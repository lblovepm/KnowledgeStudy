参考: https://blog.csdn.net/inspiredbh/article/details/74889654

	Java虚拟机先从最核心的API开始查找,防止不可信的类扮演被信任的类
	启动类加载器 Bootstrap ClassLoader：加载<JAVA_HOME>\lib目录下核心库
	扩展类加载器 Extension ClassLoader：加载<JAVA_HOME>\lib\ext目录下扩展包
	应用程序类加载器 Application ClassLoader：加载用户路径(classpath)上指定的类库
	
	双亲委派模型
		双亲委派模型要求除顶层启动类加载器外其余类加载器都应该有自己的父类加载器;
		类加载器之间通过复用关系来复用父加载器的代码
	
	双亲委派模型工作过程：
		1.当Application ClassLoader 收到一个类加载请求时,他首先不会自己去尝试加载这个类,而是将这个请求委派给父类加载器Extension ClassLoader去完成.
		2.当Extension ClassLoader收到一个类加载请求时,他首先也不会自己去尝试加载这个类,而是将请求委派给父类加载器Bootstrap ClassLoader去完成.
		3.如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类),就会让Extension ClassLoader尝试加载. 
		4.如果Extension ClassLoader也加载失败,就会使用Application ClassLoader加载.
		5.如果Application ClassLoader也加载失败,就会使用自定义加载器去尝试加载.  
		6.如果均加载失败,就会抛出ClassNotFoundException异常。 

 	双亲委派模型的实现过程：
		实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中：  
		首先会检查请求加载的类是否已经被加载过;  
		若没有被加载过：  
		递归调用父类加载器的loadClass();  
		父类加载器为空后就使用启动类加载器加载;  
		如果父类加载器和启动类加载器均无法加载请求,则调用自身的加载功能.

	双亲委派模型的优点：
		Java类伴随其类加载器具备了带有优先级的层次关系,确保了在各种加载环境的加载顺序.  
		保证了运行的安全性,防止不可信类扮演可信任的类
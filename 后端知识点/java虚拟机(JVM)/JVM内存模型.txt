JVM内存结构:

	1、程序计数器(线程私有):
		a、是当前线程所执行的字节码行号指示器,每条线程都要有一个独立的程序计数器,这类内存也称为线程的私有内存
		b、正在执行java方法的话,计数器记录的是虚拟机字节码指令的地址(当前指令的地址),如果还是native方法,则为空
		c、这个内存区域是唯一一个在虚拟集中没有规定任何OutOfMemoryError情况的区域
		
	2、java虚拟机栈(线程私有):
		a、每个方法在执行的时候会创建一个栈帧,存储了局部变量表、操作数栈、动态链接、方法返回地址等
			说明:
				局部变量表 存放了编译器可知的各种基本数据类型、对象引用(引用指针，并非对象本身),
				其中64位长度的long和double类型的数据会占用2个局部变量的空间,其余数据类型只占1个.
				局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,
				这个方法需要在栈帧中分配多大的局部变量是完全确定的,在运行期间栈帧不会改变局部变量表的大小空间
		b、每个方法从调用到执行完毕,对应一个栈帧在虚拟机栈中的入栈和出栈(通常所说的栈,一般是指虚拟机栈中的局部变量表部分)
		c、局部变量表所需内存在在编译期间完成分配,
			如果线程请求的栈深度大于虚拟机所允许的深度,则抛出StackOcerFlowError异常;
			如果虚拟机栈可以动态扩展,扩展到无法申请足够的内存,则抛出OutOfMemoryError异常
			
	3、本地方法栈(线程私有):
		和java虚拟机栈类似,主要为虚拟机使用到的native方法服务,也会抛出StackOverFlowError和OutOfMemoryError异常
		
	4、Java堆(线程共享):
		a、被所有线程共享的一块内存区域,在虚拟机启动时创建,用于存放对象实例
		b、堆可以按照可扩展来实现(通过-Xmx和-Xms来控制)
		c、当堆中没有内存可以分配给实例,也无法再扩展时,则抛出OutOfMemoryError异常
		
	5、方法区(线程共享):
		a、用于存储已被虚拟机加载的类信息、常量、静态变量等
		b、这个区域的内存回收目标主要针对常量池的回收和对类型的卸载
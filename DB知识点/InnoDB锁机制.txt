InnoDB各种锁详解:
	
	行锁:
		共享锁(S): 又称读锁.允许一个事务去读一行,阻止其他事务获得相同数据集的共享锁.
					若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁.
					这保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改.这保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改
		
		排他锁(X): 又称为写锁,排他锁指的是一个事务在一行数据加上排他锁后,其他事务不能再在其上加其他的锁.
					mysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁,
					select语句默认不会加任何锁类型,如果加排他锁可以使用select …for update语句,
					加共享锁可以使用select … lock in share mode语句.
					所以加过排他锁的数据行在其他事务种是不能修改数据的,也不能通过for update和lock in share mode锁的方式查询数据,
					但可以直接通过select …from…查询数据,因为普通查询没有任何锁机制
	
	表锁:
		意向共享锁(IS)：事务打算给数据行共享锁,事务在给一个数据行加共享锁前必须先取得该表的IS锁.
		意向排他锁(IX)：事务打算给数据行加排他锁,事务在给一个数据行加排他锁前必须先取得该表的IX锁
		
		注意:
			意向锁是InnoDB自动加的,不需用户干预.
			对于UPDATE、DELETE和INSERT语句,InnoDB会自动给涉及数据集加排他锁(X)；对于普通SELECT语句,InnoDB不会加任何锁. 
			事务可以通过以下语句显式给记录集加共享锁或排他锁：
			共享锁(S)：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE.
			排他锁(X)：SELECT * FROM table_name WHERE ... FOR UPDATE
			
	悲观锁:
		指的是对数据被外界(包括本系统当前的其他事务,以及来自外部系统的事务处理)修改持保守态度(悲观),因此,在整个数据处理过程中,将数据处于锁定状态. 
		悲观锁的实现,往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性,
		否则,即使在本系统中实现了加锁机制,也无法保证外部系统不会修改数据
		悲观锁是利用数据库本身提供的锁机制来实现的
		
	乐观锁:
		指的是假设认为数据一般情况下不会造成冲突,所以在数据进行提交更新的时候,才会正式对数据的冲突与否进行检测,如果发现冲突了,则让返回用户错误的信息,让用户决定如何去做.
		相对于悲观锁,在对数据库进行处理的时候,乐观锁并不会使用数据库提供的锁机制.一般的实现乐观锁的方式就是记录数据版本(也可以使用时间戳)
		
	注意:
		乐观锁、悲观锁 不能和 行锁、表锁混为一谈

	表级锁、行级锁、页面锁的区别:
        表级锁：开销小,加锁快；不会出现死锁；锁定粒度大,发生锁冲突的概率最高,并发度最低.
        行级锁：开销大,加锁慢；会出现死锁；锁定粒度最小,发生锁冲突的概率最低,并发度也最高.
        页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间,并发度一般
